from abc import abstractmethod
from pathlib import Path
from jinja2 import Template
from src.util import camel_snake


class TemplateBasePreProcessor:
    def __init__(self) -> None:
        pass

    def write_file(self, pre_processor_dir: Path) -> Path:
        if not pre_processor_dir.exists():
            pre_processor_dir.mkdir(parents=True, exist_ok=True)
        file_name = self._get_file_name()
        full_path = pre_processor_dir / file_name
        content = self._get_content()
        processed_content = self._get_processed_content(content)
        with open(full_path, "w", encoding="utf-8") as f:
            f.write(processed_content)
        return full_path

    @abstractmethod
    def get_template_type(self) -> str:
        pass

    def _get_file_name(self) -> str:
        tt = self.get_template_type()
        return f"process_{tt}_registry.py"

    def _get_processed_content(self, content: str) -> str:
        template_type = self.get_template_type()
        class_name = camel_snake.to_camel_case(f"process_{template_type}_registry")
        template: Template = Template(source=content)
        processed_content = template.render(
            class_name=class_name,
            render_class=self.__class__.__name__,
            template_type=template_type,
        )
        return processed_content

    def _get_content(self) -> str:
        clz = """# Auto-generated pre-processor for {{ template_type }} template registry.
# This file is generated by {{ render_class }} and should not be edited manually.

from typing import Any, cast


class {{ class_name }}:
    def __init__(self, *, registry: dict[str, Any], monad_name: str, **kwargs: Any):
        self.registry = registry.copy()
        self.monad_name = monad_name
        self._kwargs = kwargs

    def get_template_type(self) -> str:
        \"\"\"Return the type of the registry being processed.\"\"\"
        if "template_type" not in self.registry:
            raise ValueError("Registry must have a 'template_type' field.")
        tt = self.registry["template_type"]
        if not tt == "{{ template_type }}":
            raise ValueError(f"Invalid template_type: {tt}. Expected '{{ template_type }}'.")
        return tt

    def _process_reg(self) -> None:
        if "field_being_profile" in self.registry:
            fbp = cast(dict[str, Any], self.registry["field_being_profile"])
            keys = (
                "rendering_being",
                "authoring_being",
                "witnessing_being",
                "mirrorwall_being",
                "invocation_beings",
                "optional_beings",
            )
            for key in keys:
                if key in fbp and isinstance(fbp[key], list):
                    being_list = cast(list[str], fbp.get(key, []))
                    updated_list = []
                    for being in being_list:
                        if being == "{% raw %}{{ current_user }}{% endraw %}":
                            updated_list.append(self.monad_name)
                        else:
                            updated_list.append(being)
                    fbp[key] = updated_list

        if (
            "autofill" in self.registry
            and "allowed_agents" in self.registry["autofill"]
        ):
            allowed_agents = cast(
                list[str], self.registry["autofill"]["allowed_agents"]
            )

            agent_set = set(allowed_agents)
            if "{% raw %}{{ current_user }}{% endraw %}" in agent_set:
                agent_set.remove("{% raw %}{{ current_user }}{% endraw %}")

            if self.monad_name not in agent_set:
                # {% raw %}{{ current_user }}{% endraw %} is monad_name
                agent_set.add(self.monad_name)

            self.registry["autofill"]["allowed_agents"] = list(agent_set)

    def process(self) -> dict[str, Any]:
        \"\"\"Main processing method to format the {{ template_type }} registry.\"\"\"
        self._process_reg()
        return self.registry

"""
        return clz
